#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
-------------------------------------------------

    @   Author  :       Max_Pengjb
    @   date    :       2018/9/22 21:23
    @   IDE     :       PyCharm
    @   Site    :       
-------------------------------------------------
    Description :       
-------------------------------------------------
"""

__author__ = 'Max_Pengjb'

"""
汉诺塔问题源于印度一个古老传说。
相传大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。
大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。
并且规定，任何时候，在小圆盘上都不能放大圆盘，且在三根柱子之间一次只能移动一个圆盘。
问应该如何操作？

汉诺塔问题的解决思路：如果我们要思考每一步怎么移可能会非常复杂，但是可以将问题简化。
我们可以先假设除a柱最下面的盘子之外，已经成功地将a柱上面的63个盘子移到了b柱，
这时我们只要再将最下面的盘子由a柱移动到c柱即可。
当我们将最大的盘子由a柱移到c柱后，b柱上便是余下的63个盘子，a柱为空。
因此现在的目标就变成了将这63个盘子由b柱移到c柱。
这个问题和原来的问题完全一样，只是由a柱换为了b柱，规模由64变为了63。
因此可以采用相同的方法，先将上面的62个盘子由b柱移到a柱，再将最下面的盘子移到c柱。

以此内推，再以b柱为辅助，将a柱上面的62个圆盘最上面的61个圆盘移动到b柱，并将最后一块圆盘移到c柱。

我们已经发现规律，我们每次都是以a或b中一根柱子为辅助，然后先将除了最下面的圆盘之外的其他圆盘移动到辅助柱子上，再将最底下的圆盘移到c柱子上，不断重复此过程。

这个反复移动圆盘的过程就是递归，例如我们每次想解决n个圆盘的移动问题，就要先解决（n-1)个盘子进行同样操作的问题。

我们先假设a柱上只有3个圆盘，利用Python进行编程实现圆盘的移动，
代码如下：
"""


def move(n, a, b, c):
    if n == 1:
        print("{} -> {}".format(a, c))
        return
    move(n - 1, a, c, b)
    move(1, a, b, c)
    move(n - 1, b, a, c)


move(8, "a", "b", "c")
